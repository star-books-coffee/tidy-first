# Part 02. 옮긴이 특별 부록
## Chapter 6. 개발자가 테스트를 보는 3가지 관점
### TDD를 바라보는 2가지 견해
- TDD는 **지금 짜야 할 코드가 정확히 무엇인지 규정** 하는 일에 가깝다
- TDD는 테스트 작성을 통해 '짜야할 프로그램' 이라는 **문제 영역을 정확하고 체계적으로 구성해가는 개발방식** 이라고 할 수 있다
- 테스트는 전통적인 역할을 넘어서 **점진적 설계를 하는 수단** 으로 쓰여 개발의 중심이 되므로, '테스트 주도' 라고 표현 가능하다

### 개발자가 테스트를 바라보는 3가지 관점
1. 자동화를 통한 효과적 테스트에 초점을 맞추는 관점
2. 테스트를 넘어서 효과적인 개발 방법으로 확장한 관점 (일명 TDD)
3. 팀 입장에서 장기적 생산성과 변화에 대한 유연성 확보까지 고려한 관점

- 프로그래밍 언어나 테스트 대상 프로그램에 따라 확장된 개발도구를 XUnit 이라고 하는데, 자신의 작업 환경에 맞는 방법을 익히면 반복적 수작업을 줄일 수 있어 생산성이 향상된다
- 자동화 테스트를 하다보면 프로그램을 테스트하기 어렵게 작성한 경우를 발견할 수 있다
  - 이 때가 바로 테스트에 대한 1번째 관점을 벗어나 새로운 인식이 생기는 시점이다
  - 2번째 관점으로 제시한 내용에 공감할 가능성이 높다

### 테스트를 매개로 문제를 정교하게 정의하기
- TDD는 프로그래밍 영역을 벗어나서 응용할 수 있는 '시간을 극도로 효율적으로 쓰는 일' 을 알려줄 수 있다
- TDD는 충동적으로 하고 싶은 대로 코드를 짜고 남발하는 습관을 이겨내고, 지금 당장 **필요한 코드가 무엇인지 생각하고 정의하게 만드는 `스펙 정의`** 에 가깝다
- 프로그래밍을 하기 전에 "정확하게 무엇을 짤 것인지" 생각하고 정교하게 기록하는 훈련은 `문제 정의` 를 연습하는 탁월한 방법이 되었다

### 장기적 생산성과 변화에 대한 유연성 확보를 위한 투자
- 테스트를 소프트웨어 설계가 지향해야 하는 장시적 생산성, 변화에 대한 유연성 확보하기 위해 투자하는 활동으로 바라볼 수도 있다

### TDD 적용이 어렵다면
- 한참 시간이 흐른 후 발생하는 수많은 장애를 줄이기 위해, 프로그램 작성자가 직접 테스트 코드를 짜는 일은 `생산적` 인 활동이다
- 향후 내가 짠 코드를 다른 이유로 변경했을 때 발생할 수 있는 **부작용을 테스트 코드 실행을 통해 눈으로 바로 확인 가능** 하다

## Chapter 7. 소프트웨어 설계 20년 해보고 깨달은 '좋은 설계' 의 조건
- '어떻게 설계하느냐' 방법론은 개인의 선호에 달린 문제이다
- 어떤 설계 방법론이 옳은지 따지기보다, **현장에서 설계 내용을 실현하기 위해 서로 소통하는 데 가장 효과적인 방법** 을 찾아야 한다
- 모든 상황에서 모든 문제를 해결해주는 모범답안 같은 완벽한 해법은 없다
- 설계는 정교한 의사소통을 돕는 도구로 활용될 때만 의미가 있다

### 설계가 할 수 없는 것
#### 설계는 코딩을 대신해 줄 수 없다
- UML이 널리 보급되던 시절에는 다이어그램 형태로 설계만 잘하면 코드가 만들어진다는 주장과 이를 실현하려는 제품들이 시장에 퍼져 있었다

#### 소통 없이는 완벽한 설계 문서란 없다
- 설계는 코딩을 대신해주지 않는다
- 기술적 가정을 검증하지 않고, 당장 개발을 위한 소통에 쓰이지 않는 문서나 그림 형태로 설계하는 일은 지양해야 한다
- 설계 결과물은 **소통의 일부로, 함께 대화하는 맥락 (도메인) 안에서만 힘을 갖는다**
- 현장에서 함께 일하는 사람들과의 **소통하는 과정에서 설계도 만들어진다**
  - 함께 일하는 이들이 사용하는 도구와 전문지식 배경에 따라 표기법과 같은 설계 방법을 결정하는 것이 효과적이다

### 설득 또한 설계의 일부이다
- 개발팀 내에서 서로의 코드를 살펴보는 것은 매우 중요하다
  - 코드검토는 옳고 그름을 따지기 위함이 아니라, 서로의 입장을 **코드를 통해 정교하게 소통하는 일에 대한 것** 이다
- 설계를 바라볼 때 "내가 생각하기에 올바른 해법" 이 결과물이 아니라는 점을 알아야 한다
- 소프트웨어가 만드는 변화에 영향을 받는 사람들의 입장에서 옳은 방향을 추구해야 한다
- 섣불리 옳고 그름을 따지기 전에 서로 다른 입장을 이해하고, 팀으로 의사결정하는 방법을 익혀야 한다
- **설계는 어떻게 해야 할 지 떠오를 정도까지만 한다**
- 리팩토링을 통해 지속 설계를 한다
- 설계는 '정답' 을 만드는 것이 아니다
- 설계는 **일종의 의사소통 방식** 으로, 팀으로 나아가야 할 **방향에 대한 정교한 소통을 돕기 위한 일** 이라는 것에 익숙해져야 한다

## Chapter 8. 느슨한 결합 원칙을 활용한 소프트웨어 설계
- 도메인 주도라는 말을 '우리 상황에 맞춰서' 라는 의미로 이해한다
  - 우리가 다루는 비즈니스 가치, 양상, 사용하는 기술, 개발 속도, 소통 방식을 포함해 이들을 모두 함축한 말이라 여기기 때문이다

### 느슨한 결합 : 가장 중요하게 생각하는 하나의 원칙
- 시스템 구성요소가 서로 **약하게 연관되어 관계를 떼어낼 수 있고**, 한 구성요소에 변화가 생기면 **다른 구성요소에 최소한의 영향을 끼치는 상태**
- 구성요소가 다른 구성요소에 대한 **많은 지식 없이도 사용할 수 있는 상황**
- 전자는 구성요소 간의 `결합`의 양상을 말하면, 후자는 그에 따른 `효과와 결합의 범주`에 대해 말한다
- 느슨한 결합을 활용할 수 있는 3가지 기준
  1. 프로그래머들에게 익숙한 `클래스` 단위 (작성한 프로그램 수준에서 활용하기)
  2. 네트워크, 하드웨어의 발달로 나눠 짤 수 있는 상황에 어울리는 `분산프로그래밍` 형태에서 활용하기
  3. 복잡한 일을 조직화할 때 사용하는 `단위`, 자유로운 여지를 두기 위한 `경계` 를 구축하는 데 활용하기

### 1. 나의 프로그래밍에서의 느슨한 결합
#### 클래스 사이의 결합과 결합의 시점 문제
- 설계 시점에서 **구성요소를 결합시키지 않거나, 최소한의 결합 상태만 만들어두고 실행 시점에 결합을 완성하는 식** 으로 느슨한 결합을 구현하는 경우가 있다
  - 스프링 프레임워크의 구동은 이를 기반으로 하며, `의존성 주입` 이라고 한다
  - 의존 관계 선언 시에는 `타입` 수준에서 **프로그램 정합성을 확인** 한다
  - 실제 구동시점에서는 정의한 의존 관계에 따라 **실제 클래스 구동 시 구체적인 결합이 만들어진다**
- 코드의 연관성을 타입 확인만 하는 `설계 시점`, 메모리에 올라가는 `구동 시점` 으로 나누어 구성하는 유연성을 가질 수 있다
- 오랜 시간 변치 않을 내용, 미래를 위해 선택지를 열어두고 싶은 부분을 판단할 수 있어야 **유연성을 제대로 활용할 수 있다**

### 2. 분산 프로그래밍 형태에서의 느슨한 결합
#### 인터페이스 결합이 중요하지 않은 경우
- 결합의 정도가 중요한 이유는 **프로그램이 변해야 하는 경우에 발생** 한다

#### 느슨한 결합의 전형적인 사례 : 오픈 API 혹은 REST API를 통한 결합
- REST API : 방대한 구성을 가능하게 하는 웹의 기본원리에 충실한 형태를 띤 분산 API
  - 정확히 말하면 REST 형태가 아닌 원격 API 호출 방식, 오픈 API라는 표현도 자주 쓰인다
  - 이들은 모두 **서로 다른 서버에서 구동하고 네트워크 통신 규약에 따라 결합** 한다는 사실이다
  - 이는 느슨한 결합을 구현하기 좋은 방식이다
- 서로 역할을 분배하는 시점 (ex. 사업적 제휴) 에서는 주고받는 데이터 형식, 순서, 데이터양에 대해서만 약속하면 된다
  - 즉, 설계시점의 결합이 강하지 않다

### 3. 단위와 경계를 만드는 느슨한 결합
- 복잡한 일을 하기 위해서는 공통 `단위`가 필요하다
- 프로그래밍에서는 메모리에 구동하는 단위를 일원화해서 복잡한 연산을 구성하기 위해, 명령어 덩어리가 필요하다
  - 그것을 도메인에서 사람들이 다루기에 적합한 형태로 만들어야 쉽게 유지보수가 가능하다
  - 이것이 생산성에 절대적 영향을 미친다
- 이러한 단위들이 복잡한 의존 관계로 얽히며, 언젠가는 협업을 위한 덩어리가 필요한데 이를 `경계` 라고 한다
- 경계를 만들면 **경계 밖의 문제에 대해 자유로워질 수 있다**
- 하지만 복잡한 문제를 풀려면 결국 연결해야 한다
  - 연관성에 따라 문제를 표현하는 코드를 나누어 다룰 수 있으므로 효과적인 협업이 가능하다

## Chapter 9. 소프트웨어 '설계'의 정의는 변해야 한다
### 설계도의 좋은 쓰임새는 무엇인가
- 업무를 구성하는 핵심 지식을 빠르게 파악할 수 있도록 돕기 위한 것이다
- 교류가 많은 시스템일 경우, 다양한 요인에 의해 시스템 전반의 상태가 어떻게 바뀌는 지 아는 것이 굉장히 중요하다
- 그림을 설계도라고 생각하면, 개발자에게 전달하여 개발에 도움을 주어야 하는데 개발자가 원하는 정보가 충분하지 않을 경우가 있다
  - 개발 경험이 없는 사람이 개발에서 역할을 하려면 어떻게 해야 하는가?

### 현대적인 소프트웨어 설계, 새로운 정의가 필요하다
- 전통적인 설계에 대한 인식에서 벗어나자
- 소프트웨어 설계란, **배경지식이 다른** 사람과 함께 힘을 합쳐 **최상의 사용자 경험과 고객가치를 전달하기 위한 소통** 활동으로, 그 과정에서 최종 구현물 (코딩) 을 제외한 다양한 중간 산출물을 도구로 활용할 수 있다
- 개발을 모르는 사람들이 모델링 기법을 배워서 개발자가 이해할 수 있는 설계도를 그려야 하는 게 아니라, **개발 지식이 업는 사람과도 소통할 수 있다면 어떤 것이든 설계 도구로 인정해야 한다** 는 것이다

### 설계의 형식과 표기법은 본질이 아니다
- `도메인 스토리텔링` : 서로 다른 배경을 가진 사람들을 모아, **도메인 전문가가 도메인에 대한 스토리를 전달** 하고, 그것을 참가자들이 시각화하면서 **도메인 지식을 비즈니스 소프트웨어로 변환하는 협업 모델링 기법** 이다
  - 이 과정에서 도메인 지식이 잘 전달되었는지, 참가자들이 잘 이해하고 있는지 즉각 확인 이 가능하다
  - 피드백에 따라 시각화 자료를 개선하면서 서로 다른 배경을 가진 참가자들이 모두 이해할 수 있게 돕는다

### 설계 형식과 표기보다 소통이 먼저다
- 중요한 것은 형식이나 표기가 아니라 **소통이 가능하게 하는 것** 이다

### 설계 방법은 각자의 팀에 맞게 만들어간다
- 나부터 시작하여 확산시키자
- 스스로 효능을 모르는 방법을 다른 사람에게 강요하는 일은 설득력을 가질 수 없다

### 소프트웨어 설계라는 포괄적인 활동
- 소프트웨어를 만드는 일은 기본적으로 **외부 세계에 대한 우리의 인식을 시스템으로 구현하는 일** 이다
- 시스템이 잘 작동한다고 해도 필연적으로 외부 세상을 그대로 대응시킬 수 없으므로, 반드시 불일치가 발생한다
  - 하지만 시스템 내부적으로 **나름의 일관성을 유지하도록 통합해야 한다**
  - 이 때문에 시스템 상태를 알아야 하는 경우가 발생한다
- 소프트웨어는 외부 세상을 바라보는 현상적 이해를 구현한 결과이다
- 설계란 소프트웨어 구현으로 가는 과정에서의 **다양한 이해와 의사결정 양상을 총체적으로 담을 수 있는 것** 이다